const React = require('react');
const { createContext, useState, useEffect, useContext } = require('react');
const AsyncStorage = require('@react-native-async-storage/async-storage');
const { default: axiosAuth, refreshAuthToken, clearAuthData } = require('../api/axiosConfig');

const AuthContext = createContext();

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Перевіряємо наявність токена при завантаженні додатку
  useEffect(() => {
    const loadToken = async () => {
      try {
        const token = await AsyncStorage.getItem('token');
        const refreshToken = await AsyncStorage.getItem('refresh_token');
        const userId = await AsyncStorage.getItem('userId');
        const userData = await AsyncStorage.getItem('userData');
        
        if (token && userId && userData) {
          // Перевіряємо термін дії токена
          try {
            const tokenParts = token.split('.');
            if (tokenParts.length === 3) {
              const payload = JSON.parse(atob(tokenParts[1]));
              const currentTime = Date.now() / 1000;
              
              if (payload.exp && payload.exp > currentTime) {
                // Токен ще дійсний
                const parsedUserData = JSON.parse(userData);
                setUser(parsedUserData);
                console.log('[Auth] Valid token found, user logged in:', parsedUserData.email);
              } else if (refreshToken) {
                // Токен прострочений, але є refresh токен
                console.log('[Auth] Token expired, attempting refresh');
                const newToken = await refreshAuthToken();
                
                if (newToken) {
                  // Успішно оновили токен
                  console.log('[Auth] Token refreshed successfully');
                  const parsedUserData = JSON.parse(userData);
                  setUser(parsedUserData);
                } else {
                  // Не вдалося оновити токен
                  console.log('[Auth] Token refresh failed, clearing storage');
                  await clearAuthData();
                }
              } else {
                // Токен прострочений і немає refresh токена
                console.log('[Auth] Token expired and no refresh token, clearing storage');
                await clearAuthData();
              }
            } else {
              console.log('[Auth] Invalid token format, clearing storage');
              await clearAuthData();
            }
          } catch (tokenError) {
            console.error('[Auth] Error parsing token:', tokenError);
            await clearAuthData();
          }
        } else {
          console.log('[Auth] No stored authentication data found');
        }
      } catch (err) {
        console.error('[Auth] Error loading authentication data:', err);
      } finally {
        setLoading(false);
      }
    };

    // Видаляємо локальну функцію clearAuthData, оскільки ми імпортуємо її з axiosConfig
    // Використовуємо імпортовану функцію clearAuthData замість локальної

    loadToken();
  }, []);

  // Функція для входу в систему
  const login = async (email, password) => {
    setLoading(true);
    setError(null);
    
    try {
      console.log('[Auth] Attempting login with email:', email);
      
      // Відправляємо запит на Node.js API для автентифікації
      console.log('[Auth] Sending authentication request to Node.js API');
      console.log('[Auth] Request URL:', '/api/users/login');
      
      const response = await axiosAuth.post('/api/users/login', { 
        email, 
        password
      });
      
      console.log('[Auth] Response status:', response.status);
      
      console.log('[Auth] Full server response:', response.data);
      
      // Перевіряємо наявність помилок у відповіді
      if (response.data?.error || response.data?.message) {
        console.error('[Auth] Error in response data:', response.data);
        throw new Error(response.data.error_description || response.data.message || 'Помилка автентифікації');
      }
      
      if (response.data?.token && response.data?.user) {
        // Зберігаємо access token
        await AsyncStorage.setItem('token', response.data.token);
        
        // Зберігаємо refresh token, якщо він є у відповіді
        if (response.data.refreshToken) {
          await AsyncStorage.setItem('refresh_token', response.data.refreshToken);
          console.log('[Auth] Refresh token stored');
        }
        
        await AsyncStorage.setItem('userId', response.data.user.id.toString());
        
        // Зберігаємо дані користувача
        const userData = {
          id: response.data.user.id,
          name: response.data.user.name || 'Користувач',
          email: response.data.user.email,
          role: response.data.user.role || 'client',
          phone: response.data.user.phone || 'Не вказано'
        };
        
        await AsyncStorage.setItem('userData', JSON.stringify(userData));
        setUser(userData);
        
        console.log('[Auth] Login successful:', { userId: response.data.user.id });
        return true;
      } else {
        throw new Error('Неправильна відповідь від сервера');
      }
    } catch (err) {
      console.error('[Auth] Login error:', err);
      
      // Використовуємо покращену обробку помилок з axiosConfig
      let errorMessage = 'Помилка входу';
      
      if (err.isAuthError) {
        errorMessage = err.customMessage || 'Помилка автентифікації';
      } else if (err.isNetworkError) {
        errorMessage = err.customMessage || 'Проблеми з мережею';
      } else if (err.isTimeoutError) {
        errorMessage = err.customMessage || 'Час очікування вичерпано';
      } else if (err.status && err.data?.message) {
        errorMessage = err.data.message;
      } else if (err.status && err.data?.error_description) {
        errorMessage = err.data.error_description;
      } else if (err.message) {
        errorMessage = err.message;
      }
      
      setError(errorMessage);
      return false;
    } finally {
      setLoading(false);
    }
  };

  // Функція для виходу з системи
  const logout = async () => {
    try {
      // Використовуємо clearAuthData з axiosConfig для видалення даних автентифікації
      await clearAuthData();
      setUser(null);
      console.log('[Auth] User logged out successfully');
      return true;
    } catch (err) {
      console.error('[Auth] Error during logout:', err);
      return false;
    }
  };
  
  // Функція для отримання токена з перевіркою терміну дії
  const getToken = async () => {
    try {
      const token = await AsyncStorage.getItem('token');
      if (!token) {
        console.log('[Auth] No token found');
        return null;
      }
      
      // Перевіряємо термін дії токена
      try {
        const tokenParts = token.split('.');
        if (tokenParts.length === 3) {
          const payload = JSON.parse(atob(tokenParts[1]));
          const currentTime = Date.now() / 1000;
          
          if (payload.exp && payload.exp > currentTime) {
            // Токен ще дійсний
            return token;
          } else {
            // Токен прострочений, спробуємо оновити
            console.log('[Auth] Token expired, attempting refresh');
            const newToken = await refreshAuthToken();
            return newToken;
          }
        } else {
          console.log('[Auth] Invalid token format');
          return null;
        }
      } catch (error) {
        console.error('[Auth] Error parsing token:', error);
        return null;
      }
    } catch (error) {
      console.error('[Auth] Error getting token:', error);
      return null;
    }
  };

  // Функція для оновлення даних користувача
  const updateUserData = async (updatedData) => {
    try {
      // Отримуємо поточні дані користувача
      const userData = await AsyncStorage.getItem('userData');
      if (!userData) {
        console.log('[Auth] No user data found');
        return false;
      }
      
      // Оновлюємо дані користувача
      const parsedUserData = JSON.parse(userData);
      const newUserData = { ...parsedUserData, ...updatedData };
      
      // Зберігаємо оновлені дані
      await AsyncStorage.setItem('userData', JSON.stringify(newUserData));
      setUser(newUserData);
      
      console.log('[Auth] User data updated successfully');
      return true;
    } catch (error) {
      console.error('[Auth] Error updating user data:', error);
      return false;
    }
  };

  // Функція для перевірки ролі користувача
  const hasRole = (requiredRole) => {
    if (!user) return false;
    
    // Перевіряємо, чи має користувач необхідну роль
    if (Array.isArray(requiredRole)) {
      return requiredRole.includes(user.role);
    }
    
    return user.role === requiredRole;
  };

  // Функція для перевірки, чи є користувач адміністратором
  const isAdmin = () => {
    return hasRole('admin');
  };

  // Функція для перевірки, чи є користувач майстром
  const isMaster = () => {
    return hasRole('master');
  };

  // Функція для перевірки, чи є користувач клієнтом
  const isClient = () => {
    return hasRole('client');
  };

  return (
    React.createElement(AuthContext.Provider, {
      value: {
        user,
        loading,
        error,
        isAuthenticated: !!user,
        login,
        logout,
        getToken,
        updateUserData,
        hasRole,
        isAdmin,
        isMaster,
        isClient
      }
    }, children)
  );
}

function useAuth() {
  return useContext(AuthContext);
}

module.exports = {
  AuthContext,
  AuthProvider,
  useAuth
};