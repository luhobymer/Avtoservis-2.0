# Аналіз проекту Avtoservis

## ВАЖЛИВА НОТАТКА (Оновлено)
**Веб-версію (client/) відкладаємо до моменту готовності додатку до релізу. Зараз фокусуємося виключно на мобільній частині (mobile/) для публікації в Google Play та App Store.**

## Основні проблеми та необхідні доопрацювання

### 1. Архітектура бази даних та серверної частини
- **Поточний стан**: Використовується MySQL з Sequelize ORM, що потребує власного хостингу та адміністрування
- **Рекомендація**: Міграція на Supabase або Firebase для спрощення розгортання, масштабування та зменшення витрат на підтримку
- **Пріоритет**: Високий

### 2. Підтримка PWA (Progressive Web App)
- **Поточний стан**: Базова конфігурація PWA через vite-plugin-pwa, але відсутня повна реалізація сервіс-воркерів та офлайн-функціональності
- **Рекомендація**: Повна імплементація PWA з кешуванням, офлайн-режимом та push-повідомленнями
- **Пріоритет**: Високий (критично для публікації в магазинах додатків)

### 3. Оптимізація інтерфейсу для мобільних пристроїв
- **Поточний стан**: Використовується Material UI, але відсутня повна адаптація для мобільних пристроїв
- **Рекомендація**: Повний редизайн з фокусом на мобільний досвід (Mobile-First Design)
- **Пріоритет**: Високий

### 4. Система багатомовності
- **Поточний стан**: Використовується i18next, але відсутня повна локалізація всіх текстів
- **Рекомендація**: Завершити локалізацію всіх текстів та додати автоматичне визначення мови користувача
- **Пріоритет**: Середній-високий

### 5. Безпека даних
- **Поточний стан**: Базова автентифікація через JWT, відсутня двофакторна автентифікація
- **Рекомендація**: Впровадити двофакторну автентифікацію та покращити шифрування даних
- **Пріоритет**: Високий

## Другорядні проблеми та доопрацювання

### 1. Офлайн-режим
- **Поточний стан**: Відсутня підтримка офлайн-режиму
- **Рекомендація**: Реалізувати локальне зберігання даних та синхронізацію при відновленні з'єднання
- **Пріоритет**: Середній

### 2. Оптимізація продуктивності
- **Поточний стан**: Відсутня оптимізація завантаження ресурсів та кешування
- **Рекомендація**: Впровадити ледаче завантаження компонентів, оптимізацію зображень та кешування API-запитів
- **Пріоритет**: Середній

### 3. Аналітика та моніторинг
- **Поточний стан**: Відсутня система аналітики користувацької активності
- **Рекомендація**: Інтеграція з Google Analytics або іншими інструментами аналітики
- **Пріоритет**: Низький

### 4. Розширені функції для користувачів
- **Поточний стан**: Базовий функціонал управління автомобілями та записами на обслуговування
- **Рекомендація**: Додати нагадування про технічне обслуговування, інтеграцію з календарем, розширену історію обслуговування
- **Пріоритет**: Середній

### 5. Тестування
- **Поточний стан**: Відсутні автоматизовані тести
- **Рекомендація**: Впровадити модульні та інтеграційні тести для забезпечення стабільності додатку
- **Пріоритет**: Середній

### 6. Документація
- **Поточний стан**: Мінімальна документація проекту
- **Рекомендація**: Створити повну документацію API та інструкції для розробників
- **Пріоритет**: Низький

## Технічний борг

1. Застарілі версії залежностей в package.json
2. Відсутність типізації (TypeScript)
3. Змішування стилів кодування в різних файлах
4. Відсутність єдиного підходу до обробки помилок
5. Недостатнє логування подій на сервері

## Наступні кроки

1. Пріоритизувати завдання на основі бізнес-вимог
2. Створити дорожню карту розробки з часовими рамками
3. Розпочати з найбільш критичних проблем (архітектура бази даних, PWA, мобільний інтерфейс)
4. Впровадити CI/CD для автоматизації розгортання
5. Регулярно переглядати та оновлювати план розробки

## План вичистки поля `service_type`

### Цілі

- Зробити `service_id` єдиним джерелом істини для звʼязку записів (`appointments`, `service_history`, сервісні записи) з довідником `services`.
- Перевести всю бізнес-логіку з використання `service_type` (рядок) на використання `service_id` (FK).
- Залишити `service_type` лише як похідну/декоративну ознаку (UI‑тег) там, де це виправдано, або повністю прибрати після міграції.
- Виконати міграцію поетапно, без поломки існуючих даних та мобільного/веб‑клієнта.

### Етап 0. Інвентаризація та правила

1. Побудувати повний список використань `service_type`:
   - База даних: таблиці `appointments`, `service_history`, допоміжні SQL‑скрипти (`*_appointments_*`, `add_missing_services.sql`, `migrate-supabase.mjs` тощо).
   - Backend (`server/`): контролери, типи, місця, де `service_type` впливає на логіку або фільтрацію.
   - Мобільний додаток (`mobile/`): DAO, екрани, нагадування, статистика.
   - Веб‑клієнт (`client/`): DAO, сторінки з історією та записами.
   - Тести та діагностичні скрипти.
2. Встановити правило: новий код **не будує логіку** на `service_type`, а використовує тільки `service_id` та повʼязані таблиці.
3. Позначити в коді місця, де `service_type` вже виконує лише роль UI‑тегу, без впливу на бізнес‑логіку.

### Етап 1. Рівень бази даних (Supabase)

#### 1.1. Таблиця `appointments`

1. Переконатися, що:
   - Колонка `service_id` існує та має коректний `FOREIGN KEY` на `services(id)` (скрипт `fix_appointments_services_relationship.sql` вже створений).
   - Індекс `idx_appointments_service_id` створений та використовується.
2. Підготувати та виконати SQL:
   - Перевірка даних: знайти записи без `service_id`, але з заповненим `service_type`.
   - План backfill: таблиця відповідності між `service_type` (старі значення) та `services.id` (нові послуги).
   - Оновити `appointments.service_id` на основі карти відповідності.
3. Після заповнення:
   - Зробити `service_id` основною колонкою для всіх join до `services`.
   - Перевести `service_type` у режим:
     - або `NULLABLE` + значення за замовчуванням (UI‑тег),
     - або зафіксований список категорій (`service`, `repair`, `diagnostics`, `other`), не використовуючи його для звʼязків.

#### 1.2. Таблиця `service_history`

1. Спроєктувати додаткове поле:
   - `service_id UUID NULL REFERENCES services(id)` або
   - окремий звʼязок через `service_records` (якщо бізнес‑логіка вимагає).
2. Підготувати SQL:
   - Додавання колонки `service_id` до `service_history`.
   - Індекс по `service_id` для швидких join.
3. План заповнення:
   - Використати існуючі поля (`description`, звʼязок з `service_records`, `appointments`) для визначення відповідного `services.id`.
   - Поступово backfill `service_id` для існуючих записів.
4. Після заповнення:
   - Звести використання `service_history.service_type` до UI‑тегу або підготувати окремий етап для його видалення/спрощення.

#### 1.3. Скрипти міграцій та діагностики

1. Оновити `scripts/migrate-supabase.mjs`, щоб:
   - Вважати `service_id` обовʼязковою частиною схеми для `appointments` і `service_history`.
   - Не покладатися на `service_type` для побудови звʼязків.
2. Оновити/додати SQL‑скрипти:
   - Перевірка узгодженості `appointments.service_id` ↔ `services.id`.
   - Перевірка узгодженості `service_history.service_id` ↔ `services.id`.
3. Залишити `schedule_maintenance()` у `supabase/queries/triggers.sql` як окрему бізнес‑функцію (там `service_type` — текстова категорія для рекомендацій, не FK).

### Етап 2. Backend (`server/`)

1. Проаналізувати всі контролери, де повертається або використовується `service_type`:
   - `server/controllers/serviceRecordController.js`.
   - Інші контролери, повʼязані з `appointments`, `service_history`, `service_records`.
2. Переписати логіку:
   - Використовувати `service_id` + join до `services` для формування відповіді API (назва, ціна, тривалість, категорія).
   - Не використовувати `service_type` для фільтрації, сортування, статистики.
3. Формат відповіді API:
   - Для всіх ендпоінтів, де повертається інформація про послугу, повертати:
     - `service_id`
     - `service_name`
     - `service_price`
     - `service_duration`
     - `service_category` (якщо потрібна категорія, брати її з таблиці `services`).
4. Де потрібно зберегти стару сумісність:
   - Тимчасово продублювати поле `service_type` у відповіді як похідне від `service_category`, але не використовувати його всередині бекенду.

### Етап 3. Мобільний додаток (`mobile/`)

#### 3.1. Записи на сервіс (appointments)

1. DAO/сервіси:
   - `mobile/api/appointmentsService.js`: уже використовує `service_id` для join до `services`, зберегти цей підхід як стандарт.
   - `mobile/api/dao/appointmentsDao.js`: переведено на `service_id` (адмінський список) — вважати етап виконаним.
   - `mobile/api/appointmentsApi.js`: актуалізувати, щоб для всіх сценаріїв використовувався `service_id`, а не `service_type`.
2. Екрани:
   - `AppointmentsScreen`, `AppointmentDetailsScreen`, `MasterDashboardScreen`:
     - Використовувати `service_name` як основний текст.
     - `service_type` залишити лише як fallback або зовсім прибрати після того, як усі записи матимуть коректний `service_id` та звʼязаний `service_name`.
   - `CreateAppointmentScreen`:
     - Вже обирає послугу за `service_id` через `getAllServices`.
     - `serviceType` у стані форми використовувати як категорію (UI‑рівень) та джерело для `service_type` у БД до завершення міграції.
3. Нагадування:
   - `mobile/api/reminderService.js` та `ServiceRemindersScreen`:
     - Поступово перейти від вільного тексту до структури, де можливий звʼязок із `service_id`, щоб нагадування привʼязувалися до конкретної послуги.

#### 3.2. Історія сервісу та сервісна книга

1. Екрани:
   - `ServiceHistoryScreen`, `ServiceBookScreen`, `ServiceRecordsScreen`, `ServiceRecordDetails`, `ServiceRecordsManagement`, `CreateServiceRecord`, `EditServiceRecord`.
2. План:
   - Узгодити, де джерелом правди є `service_history`, а де `service_records`.
   - Додати `service_id` у відповідні DAO, якщо таблиця підтримує FK.
   - В UI відображати назву послуги через join до `services` або `service_records`, не через розпарсений `service_type`/`description`.

### Етап 4. Веб‑клієнт (`client/`)

1. DAO:
   - `client/src/api/dao/appointmentsDao.js`: перейти на `service_id` + join до `services`, аналогічно мобільному DAO.
   - `client/src/api/dao/serviceRecordsDao.js`: використовувати `service_id` там, де це можливо, замість `service_type` або розбору рядків.
2. Сторінки:
   - `Appointments.jsx`, `AppointmentDetails.jsx`: відображати послугу через `service_name`, для фільтрації використовувати категорії з `services`.
   - `ServiceRecords.jsx`, `ServiceRecordDetails.jsx`: відмовитися від логіки, яка покладається на `service_type` як джерело структури, перейти на `service_id`.

### Етап 5. Переклади та UI‑мітки

1. Оновити `mobile/locales/*/translation.json` та веб‑локалізації:
   - Всі тексти, які описують “тип сервісу”, перевірити та привʼязати до категорій/назв із таблиці `services`, а не до сирих значень `service_type` з БД.
2. Домовитися про уніфікований список категорій:
   - Наприклад: `maintenance`, `repair`, `diagnostics`, `other`.
   - Зберігати його або в таблиці `services` (поле `category`), або в окремому довіднику.

### Етап 6. Чистка SQL‑скриптів та допоміжних інструментів

1. Оновити всі SQL‑скрипти, де join робиться по `service_type`:
   - Наприклад, `add_missing_services.sql`, `update_appointments_with_service_id.sql`, діагностичні скрипти в корені репозиторію.
   - Замінити join по `service_type` на join по `service_id` або через карту відповідності.
2. Оновити `SUPABASE_QUERIES_AUDIT_PLAN.md`, додавши чек‑поінти для валідації:
   - Відсутність записів з `service_id IS NULL` там, де він має бути.
   - Відсутність розбіжностей між `service_type` і `services.category` (на час перехідного періоду).

### Етап 7. Тестування та поступова відмова від `service_type`

1. Автоматизовані тести:
   - Додати тестові сценарії для DAO (mobile/client), які перевіряють, що всі join йдуть через `service_id`.
   - Для backend‑контролерів — тести, які гарантують, що відповіді містять `service_id` та `service_name` і не покладаються на `service_type`.
2. Ручне тестування:
   - Створення, перегляд, редагування та скасування записів на сервіс у мобільному додатку.
   - Перегляд історії сервісу та сервісної книги.
3. Після стабільної роботи:
   - Оцінити, чи є ще сенс тримати `service_type` в структурі.
   - Якщо ні — підготувати окремий план/SQL для:
     - або видалення колонки,
     - або перетворення її на похідне поле (наприклад, `generated column` на основі `services.category`).
